#pragma once

#include <string>
#include <unordered_map>

typedef enum
{
    A_EOF = 0, // 0 - End of file
    A_EPSILON = -1,
    A_DOLLAR_SING = -2,
    A_PROGRAM = -3,
    A_NAME = -4,
    A_BEGIN = -5,
    A_END = -6,
    A_SEMICOLON = -7, // ";"
    A_VAR = -8,
    A_COLON = -9,   //  ":"
    A_ASSIGN = -10, //  ":="
    A_PROCEDURE = -11,
    A_LEFT_PARENTHESIS = -12,  //  "("
    A_RIGHT_PARENTHESIS = -13, //  ")"
    A_IN = -14,
    A_STRUCT = -15,
    A_LEFT_BRACES = -16,  //  "{"
    A_RIGHT_BRACES = -17, //  "}"
    A_COMMA = -18,        //  ","
    A_APOSTROPHE = -19,
    A_IF = -20,
    A_THEN = -21,
    A_FI = -22,
    A_UNLESS = -23,
    A_DO = -24,
    A_OD = -25,
    A_CASE = -26,
    A_OF = -27,
    A_ESAC = -28,
    A_ELSE = -29,
    A_INT_LITERAL = -30,
    A_RANGE = -31,
    A_OTHERWISE = -32,
    A_WHILE = -33,
    A_RETURN = -34,
    A_OR_LOGIC = -35,  //  "||"
    A_AND_LOGIC = -36, //  "&&"
    A_NOT = -37,
    A_POWER = -38, // "^"
    A_NEW = -39,
    A_REF = -40,
    A_DEREF = -41,
    A_DOT = -42, //  "."
    A_EMPTY = -43,
    A_LESS_THAN = -44,          //  "<"
    A_LESS_THAN_EQUAL = -45,    //  "<="
    A_GREATER_THAN = -46,       //  ">"
    A_GREATER_THAN_EQUAL = -47, //  ">="
    A_EQUAL = -48,              //  "="
    A_DIFFERENT = -49,          // "<>"
    A_PLUS = -50,               // "+"
    A_MINUS = -51,              // "-"
    A_MULTIPLY = -52,           // "*"
    A_DIVIDE = -53,             // "/"
    A_FLOAT_LITERAL = -54,
    A_STRING_LITERAL = -55,
    A_NULL = -56,
    A_TRUE = -57,
    A_FALSE = -58,
    A_FLOAT = -59,
    A_INT = -60,
    A_STRING = -61,
    A_BOOL = -62,
    A_ID = -63,
    A_SINGLE_COMMENT = -64,
    A_MULTI_COMMENT = -65,
    A_LEFT_BRACKET = -66,
    A_RIGHT_BRACKET = -67,
    A_END_LINE = -68
} ATOMIC_SYMBOLS;

static const std::unordered_map<int, std::string> ATOMIC_SYMBOLS_STRINGS = {
    {A_EOF, "A_EOF"},
    {A_PROGRAM, "A_PROGRAM"},
    {A_PROCEDURE, "A_PROCEDURE"},
    {A_BEGIN, "A_BEGIN"},
    {A_END, "A_END"},
    {A_IF, "A_IF"},
    {A_THEN, "A_THEN"},
    {A_ELSE, "A_ELSE"},
    {A_FI, "A_FI"},
    {A_WHILE, "A_WHILE"},
    {A_DO, "A_DO"},
    {A_OD, "A_OD"},
    {A_UNLESS, "A_UNLESS"},
    {A_CASE, "A_CASE"},
    {A_OF, "A_OF"},
    {A_ESAC, "A_ESAC"},
    {A_OTHERWISE, "A_OTHERWISE"},
    {A_RETURN, "A_RETURN"},
    {A_VAR, "A_VAR"},
    {A_IN, "A_IN"},
    {A_NOT, "A_NOT"},
    {A_NEW, "A_NEW"},
    {A_REF, "A_REF"},
    {A_DEREF, "A_DEREF"},
    {A_NULL, "A_NULL"},
    {A_STRUCT, "A_STRUCT"},
    {A_BOOL, "A_BOOL"},
    {A_FLOAT, "A_FLOAT"},
    {A_INT, "A_INT"},
    {A_STRING, "A_STRING"},
    {A_STRING_LITERAL, "A_STRING_LITERAL"},
    {A_INT_LITERAL, "A_INA_LITERAL"},
    {A_FLOAT_LITERAL, "A_FLOAA_LITERAL"},
    {A_TRUE, "A_TRUE"},
    {A_FALSE, "A_FALSE"},
    {A_NAME, "A_NAME"},
    {A_SINGLE_COMMENT, "A_SINGLE_COMMENT"},
    {A_MULTI_COMMENT, "A_MULTI_COMMENT"},
    {A_SEMICOLON, "A_SEMICOLON"},
    {A_COLON, "A_COLON"},
    {A_COMMA, "A_COMMA"},
    {A_ASSIGN, "A_ASSIGN"},
    {A_DOT, "A_DOT"},
    {A_LEFT_BRACKET, "A_LEFA_BRACKET"},
    {A_RIGHT_BRACKET, "A_RIGHA_BRACKET"},
    {A_LEFT_PARENTHESIS, "A_LEFA_PARENTHESIS"},
    {A_RIGHT_PARENTHESIS, "A_RIGHA_PARENTHESIS"},
    {A_LEFT_BRACES, "A_LEFA_BRACES"},
    {A_RIGHT_BRACES, "A_RIGHA_BRACES"},
    {A_OR_LOGIC, "A_OR_LOGIC"},
    {A_AND_LOGIC, "A_AND_LOGIC"},
    {A_LESS_THAN, "A_LESS_THAN"},
    {A_LESS_THAN_EQUAL, "A_LESS_THAN_EQUAL"},
    {A_GREATER_THAN, "A_GREATER_THAN"},
    {A_GREATER_THAN_EQUAL, "A_GREATER_THAN_EQUAL"},
    {A_EQUAL, "A_EQUAL"},
    {A_DIFFERENT, "A_DIFFERENT"},
    {A_PLUS, "A_PLUS"},
    {A_MINUS, "A_MINUS"},
    {A_MULTIPLY, "A_MULTIPLY"},
    {A_DIVIDE, "A_DIVIDE"},
    {A_POWER, "A_POWER"},
    {A_END_LINE, "A_END_LINE"},
    {A_RANGE, "A_RANGE"}};

typedef enum
{
    P_PROGRAM = 2,
    P_DECLS = 3,
    P_DECL = 4,
    P_DECLS_ = 5,
    P_VAR_DECL = 6,
    P_PROC_DECL = 7,
    P_REC_DECL = 8,
    P_RS_VAR_DECL = 9,
    P_TYPE = 10,
    P_VAR_INIT = 11,
    P_EXP = 12,
    P_PARAMS = 13,
    P_PROC_RET_DECL = 14,
    P_PROC_BODY = 15,
    P_DECLS_OPT = 16,
    P_STMT_LIST = 17,
    P_REC_FIELDS = 18,
    P_PARAMFIELD_DECL = 19,
    P_REC_FIELDS_ = 20,
    P_PARAMS_ = 21,
    P_STMT = 22,
    P_STMT_LIST_ = 23,
    P_ASSIGN_OR_CALL_STMT = 24,
    P_IF_STMT = 25,
    P_WHILE_STMT = 26,
    P_RETURN_STMT = 27,
    P_REGISTER = 28,
    P_ATRIBUTE = 29,
    P_DEREF_VAR = 30,
    P_EXPS = 31,
    P_EXPS_ = 32,
    P_ELSE_PART = 33,
    P_CASES = 34,
    P_CASE_DEFAULT = 35,
    P_CASE = 36,
    P_CASE_ = 37,
    P_INTERVALS = 38,
    P_INTERVAL = 39,
    P_INTERVALS_ = 40,
    P_CASE_RANGE = 41,
    P_AND_EXP = 42,
    P_EXP_ = 43,
    P_NOT_EXP = 44,
    P_AND_EXP_ = 45,
    P_REL_EXP = 46,
    P_ADD_EXP = 47,
    P_REL_EXP_ = 48,
    P_REL_OP = 49,
    P_MULT_EXP = 50,
    P_ADD_EXP_ = 51,
    P_ADD_OP = 52,
    P_POW_EXP = 53,
    P_MULT_EXP_ = 54,
    P_MULT_OP = 55,
    P_VALUE = 56,
    P_POW_EXP_ = 57,
    P_VAR_OR_CALL = 58,
    P_LITERAL = 59,
    P_REF_VAR = 60,
    P_VAR = 61,
    P_DE_VAR = 62,
    P_FUNC_CALL = 63,
    P_BOOL_LITERAL = 64
} PRODUCTION_SYMBOLS;

// std::map<int, std::string> symbol_map = {
//     {-63, "id"},
//     {-62, "bool"},
//     {-61, "string"},
//     {-60, "int"},
//     {-59, "float"},
//     {-58, "false"},
//     {-57, "true"},
//     {-56, "null"},
//     {-55, "STRING_LITERAL"},
//     {-54, "FLOAT_LITERAL"},
//     {-53, "/"},
//     {-52, "*"},
//     {-51, "-"},
//     {-50, "+"},
//     {-49, "<>"},
//     {-48, "="},
//     {-47, ">="},
//     {-46, ">"},
//     {-45, "<="},
//     {-44, "<"},
//     {-43, ""},
//     {-42, "."},
//     {-41, "deref"},
//     {-40, "ref"},
//     {-39, "new"},
//     {-38, "^"},
//     {-37, "not"},
//     {-36, "&&"},
//     {-35, "||"},
//     {-34, "return"},
//     {-33, "while"},
//     {-32, "otherwise"},
//     {-31, ".."},
//     {-30, "INT_LITERAL"},
//     {-29, "else"},
//     {-28, "esac"},
//     {-27, "of"},
//     {-26, "case"},
//     {-25, "od"},
//     {-24, "do"},
//     {-23, "unless"},
//     {-22, "fi"},
//     {-21, "then"},
//     {-20, "if"},
//     {-19, "EXP''"},
//     {-18, ","},
//     {-17, "}"},
//     {-16, "{"},
//     {-15, "struct"},
//     {-14, "in"},
//     {-13, ")"},
//     {-12, "("},
//     {-11, "procedure"},
//     {-10, ":="},
//     {-9, ":"},
//     {-8, "var"},
//     {-7, ";"},
//     {-6, "end"},
//     {-5, "begin"},
//     {-4, "NAME"},
//     {-2, "$"},
//     {-1, "Îµ"},
//     {1, "program"},
//     {2, "PROGRAM"},
//     {3, "DECLS"},
//     {4, "DECL"},
//     {5, "DECLS_"},
//     {6, "VAR_DECL"},
//     {7, "PROC_DECL"},
//     {8, "REC_DECL"},
//     {9, "RS_VAR_DECL"},
//     {10, "TYPE"},
//     {11, "VAR_INIT"},
//     {12, "EXP"},
//     {13, "PARAMS"},
//     {14, "PROC_RET_DECL"},
//     {15, "PROC_BODY"},
//     {16, "DECLS_OPT"},
//     {17, "STMT_LIST"},
//     {18, "REC_FIELDS"},
//     {19, "PARAMFIELD_DECL"},
//     {20, "REC_FIELDS_"},
//     {21, "PARAMS_"},
//     {22, "STMT"},
//     {23, "STMT_LIST_"},
//     {24, "ASSIGN_OR_CALL_STMT"},
//     {25, "IF_STMT"},
//     {26, "WHILE_STMT"},
//     {27, "RETURN_STMT"},
//     {28, "REGISTER"},
//     {29, "ATRIBUTE"},
//     {30, "DEREF_VAR"},
//     {31, "EXPS"},
//     {32, "EXPS_"},
//     {33, "ELSE_PART"},
//     {34, "CASES"},
//     {35, "CASE_DEFAULT"},
//     {36, "CASE"},
//     {37, "CASE_"},
//     {38, "INTERVALS"},
//     {39, "INTERVAL"},
//     {40, "INTERVALS_"},
//     {41, "CASE_RANGE"},
//     {42, "AND_EXP"},
//     {43, "EXP_"},
//     {44, "NOT_EXP"},
//     {45, "AND_EXP_"},
//     {46, "REL_EXP"},
//     {47, "ADD_EXP"},
//     {48, "REL_EXP_"},
//     {49, "REL_OP"},
//     {50, "MULT_EXP"},
//     {51, "ADD_EXP_"},
//     {52, "ADD_OP"},
//     {53, "POW_EXP"},
//     {54, "MULT_EXP_"},
//     {55, "MULT_OP"},
//     {56, "VALUE"},
//     {57, "POW_EXP_"},
//     {58, "VAR_OR_CALL"},
//     {59, "LITERAL"},
//     {60, "REF_VAR"},
//     {61, "VAR"},
//     {62, "DE_VAR"},
//     {63, "FUNC_CALL"},
//     {64, "BOOL_LITERAL"},
// };
