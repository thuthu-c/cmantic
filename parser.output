Terminals unused in grammar

    A_LINE
    '['
    ']'
    A_EQUAL


Grammar

    0 $accept: main $end

    1 main: program_prod
    2     | ε

    3 program_prod: A_PROGRAM A_NAME A_BEGIN optional_declaration_list A_END

    4 optional_declaration_list: ε
    5                          | declaration_list

    6 declaration_list: declaration
    7                 | declaration_list ';' declaration

    8 declaration: var_declaration
    9            | proc_declaration
   10            | rec_declaration

   11 var_declaration: A_VAR A_NAME ':' type_spec optional_assign_exp
   12                | A_VAR A_NAME A_ASSIGN exp

   13 optional_assign_exp: ε
   14                    | A_ASSIGN exp

   15 type_spec: A_FLOAT
   16          | A_INT
   17          | A_STRING
   18          | A_BOOL
   19          | A_NAME
   20          | A_REF '(' type_spec ')'

   21 proc_declaration: A_PROCEDURE A_NAME '(' optional_param_list ')' optional_return_type A_BEGIN optional_proc_decls_in_block stmt_list A_END

   22 optional_param_list: ε
   23                    | param_list

   24 param_list: paramfield_decl
   25           | param_list ',' paramfield_decl

   26 paramfield_decl: A_NAME ':' type_spec

   27 optional_return_type: ε
   28                     | ':' type_spec

   29 optional_proc_decls_in_block: ε
   30                             | optional_declaration_list A_IN

   31 stmt_list: ε
   32          | stmt_sequence

   33 stmt_sequence: stmt
   34              | stmt ';' stmt_sequence

   35 rec_declaration: A_STRUCT A_NAME '{' optional_rec_field_list '}'

   36 optional_rec_field_list: ε
   37                        | rec_field_list

   38 rec_field_list: paramfield_decl
   39               | rec_field_list ';' paramfield_decl

   40 exp: literal
   41    | call_stmt_as_exp
   42    | A_NEW A_NAME
   43    | var_access
   44    | ref_var
   45    | deref_var
   46    | '(' exp ')'
   47    | A_NOT exp
   48    | exp A_OR_LOGIC exp
   49    | exp A_AND_LOGIC exp
   50    | exp '<' exp
   51    | exp A_LESS_THAN_EQUAL exp
   52    | exp '>' exp
   53    | exp A_GREATER_THAN_EQUAL exp
   54    | exp '=' exp
   55    | exp A_DIFFERENT exp
   56    | exp '+' exp
   57    | exp '-' exp
   58    | exp '*' exp
   59    | exp '/' exp
   60    | exp '^' exp

   61 ref_var: A_REF '(' var_access ')'

   62 deref_var: A_DEREF '(' var_access ')'
   63          | A_DEREF '(' deref_var ')'

   64 var_access: A_NAME
   65           | exp '.' A_NAME

   66 literal: FLOAT_LITERAL
   67        | INT_LITERAL
   68        | STRING_LITERAL
   69        | bool_literal
   70        | A_NULL

   71 bool_literal: A_TRUE
   72             | A_FALSE

   73 stmt: assign_stmt
   74     | if_stmt
   75     | while_stmt
   76     | return_stmt
   77     | call_stmt

   78 assign_stmt: var_access A_ASSIGN exp
   79            | deref_var A_ASSIGN exp

   80 if_stmt: A_IF exp A_THEN stmt_list optional_else_clause A_FI
   81        | A_UNLESS exp A_DO stmt_list optional_else_clause A_OD
   82        | A_CASE exp A_OF case_list optional_otherwise_clause A_ESAC

   83 optional_else_clause: ε
   84                     | A_ELSE stmt_list

   85 case_list: case_clause
   86          | case_list '|' case_clause

   87 case_clause: case_label_list ':' stmt_list

   88 case_label_list: case_label_element
   89                | case_label_list ',' case_label_element

   90 case_label_element: INT_LITERAL
   91                   | INT_LITERAL A_RANGE INT_LITERAL

   92 optional_otherwise_clause: ε
   93                          | A_OTHERWISE stmt_list

   94 while_stmt: A_WHILE exp A_DO stmt_list A_OD

   95 return_stmt: A_RETURN optional_exp_val

   96 optional_exp_val: ε
   97                 | exp

   98 call_stmt: A_NAME '(' optional_arg_list ')'

   99 call_stmt_as_exp: A_NAME '(' optional_arg_list ')'

  100 optional_arg_list: ε
  101                  | arg_list

  102 arg_list: exp
  103         | arg_list ',' exp


Terminals, with rules where they appear

    $end (0) 0
    '(' (40) 20 21 46 61 62 63 98 99
    ')' (41) 20 21 46 61 62 63 98 99
    '*' (42) 58
    '+' (43) 56
    ',' (44) 25 89 103
    '-' (45) 57
    '.' (46) 65
    '/' (47) 59
    ':' (58) 11 26 28 87
    ';' (59) 7 34 39
    '<' (60) 50
    '=' (61) 54
    '>' (62) 52
    '[' (91)
    ']' (93)
    '^' (94) 60
    '{' (123) 35
    '|' (124) 86
    '}' (125) 35
    error (256)
    INT_LITERAL <ival> (258) 67 90 91
    FLOAT_LITERAL <fval> (259) 66
    A_NAME <sval> (260) 3 11 12 19 21 26 35 42 64 65 98 99
    A_LINE (261)
    STRING_LITERAL (262) 68
    A_PROGRAM (263) 3
    A_BEGIN (264) 3 21
    A_END (265) 3 21
    A_PROCEDURE (266) 21
    A_VAR (267) 11 12
    A_IF (268) 80
    A_THEN (269) 80
    A_ELSE (270) 84
    A_FI (271) 80
    A_WHILE (272) 94
    A_DO (273) 81 94
    A_OD (274) 81 94
    A_RETURN (275) 95
    A_UNLESS (276) 81
    A_CASE (277) 82
    A_OF (278) 82
    A_ESAC (279) 82
    A_OTHERWISE (280) 93
    A_TRUE (281) 71
    A_FALSE (282) 72
    A_FLOAT (283) 15
    A_INT (284) 16
    A_STRING (285) 17
    A_BOOL (286) 18
    A_NULL (287) 70
    A_STRUCT (288) 35
    A_IN (289) 30
    A_NOT (290) 47
    A_NEW (291) 42
    A_REF (292) 20 61
    A_DEREF (293) 62 63
    A_U_MINUS (294)
    A_U_PLUS (295)
    A_ASSIGN (296) 12 14 78 79
    A_LESS_THAN_EQUAL (297) 51
    A_GREATER_THAN_EQUAL (298) 53
    A_DIFFERENT (299) 55
    A_EQUAL (300)
    A_OR_LOGIC (301) 48
    A_AND_LOGIC (302) 49
    A_RANGE (303) 91


Nonterminals, with rules where they appear

    $accept (68)
        on left: 0
    main (69)
        on left: 1 2
        on right: 0
    program_prod (70)
        on left: 3
        on right: 1
    optional_declaration_list (71)
        on left: 4 5
        on right: 3 30
    declaration_list (72)
        on left: 6 7
        on right: 5 7
    declaration (73)
        on left: 8 9 10
        on right: 6 7
    var_declaration (74)
        on left: 11 12
        on right: 8
    optional_assign_exp (75)
        on left: 13 14
        on right: 11
    type_spec (76)
        on left: 15 16 17 18 19 20
        on right: 11 20 26 28
    proc_declaration (77)
        on left: 21
        on right: 9
    optional_param_list (78)
        on left: 22 23
        on right: 21
    param_list (79)
        on left: 24 25
        on right: 23 25
    paramfield_decl (80)
        on left: 26
        on right: 24 25 38 39
    optional_return_type (81)
        on left: 27 28
        on right: 21
    optional_proc_decls_in_block (82)
        on left: 29 30
        on right: 21
    stmt_list (83)
        on left: 31 32
        on right: 21 80 81 84 87 93 94
    stmt_sequence (84)
        on left: 33 34
        on right: 32 34
    rec_declaration (85)
        on left: 35
        on right: 10
    optional_rec_field_list (86)
        on left: 36 37
        on right: 35
    rec_field_list (87)
        on left: 38 39
        on right: 37 39
    exp (88)
        on left: 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60
        on right: 12 14 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 65 78 79 80 81 82 94 97 102 103
    ref_var (89)
        on left: 61
        on right: 44
    deref_var (90)
        on left: 62 63
        on right: 45 63 79
    var_access (91)
        on left: 64 65
        on right: 43 61 62 78
    literal (92)
        on left: 66 67 68 69 70
        on right: 40
    bool_literal (93)
        on left: 71 72
        on right: 69
    stmt (94)
        on left: 73 74 75 76 77
        on right: 33 34
    assign_stmt (95)
        on left: 78 79
        on right: 73
    if_stmt (96)
        on left: 80 81 82
        on right: 74
    optional_else_clause (97)
        on left: 83 84
        on right: 80 81
    case_list (98)
        on left: 85 86
        on right: 82 86
    case_clause (99)
        on left: 87
        on right: 85 86
    case_label_list (100)
        on left: 88 89
        on right: 87 89
    case_label_element (101)
        on left: 90 91
        on right: 88 89
    optional_otherwise_clause (102)
        on left: 92 93
        on right: 82
    while_stmt (103)
        on left: 94
        on right: 75
    return_stmt (104)
        on left: 95
        on right: 76
    optional_exp_val (105)
        on left: 96 97
        on right: 95
    call_stmt (106)
        on left: 98
        on right: 77
    call_stmt_as_exp (107)
        on left: 99
        on right: 41
    optional_arg_list (108)
        on left: 100 101
        on right: 98 99
    arg_list (109)
        on left: 102 103
        on right: 101 103


State 0

    0 $accept: • main $end
    1 main: • program_prod
    2     | ε •  [$end]
    3 program_prod: • A_PROGRAM A_NAME A_BEGIN optional_declaration_list A_END

    A_PROGRAM  shift, and go to state 1

    $default  reduce using rule 2 (main)

    main          go to state 2
    program_prod  go to state 3


State 1

    3 program_prod: A_PROGRAM • A_NAME A_BEGIN optional_declaration_list A_END

    A_NAME  shift, and go to state 4


State 2

    0 $accept: main • $end

    $end  shift, and go to state 5


State 3

    1 main: program_prod •

    $default  reduce using rule 1 (main)


State 4

    3 program_prod: A_PROGRAM A_NAME • A_BEGIN optional_declaration_list A_END

    A_BEGIN  shift, and go to state 6


State 5

    0 $accept: main $end •

    $default  accept


State 6

    3 program_prod: A_PROGRAM A_NAME A_BEGIN • optional_declaration_list A_END
    4 optional_declaration_list: ε •  [A_END]
    5                          | • declaration_list
    6 declaration_list: • declaration
    7                 | • declaration_list ';' declaration
    8 declaration: • var_declaration
    9            | • proc_declaration
   10            | • rec_declaration
   11 var_declaration: • A_VAR A_NAME ':' type_spec optional_assign_exp
   12                | • A_VAR A_NAME A_ASSIGN exp
   21 proc_declaration: • A_PROCEDURE A_NAME '(' optional_param_list ')' optional_return_type A_BEGIN optional_proc_decls_in_block stmt_list A_END
   35 rec_declaration: • A_STRUCT A_NAME '{' optional_rec_field_list '}'

    A_PROCEDURE  shift, and go to state 7
    A_VAR        shift, and go to state 8
    A_STRUCT     shift, and go to state 9

    $default  reduce using rule 4 (optional_declaration_list)

    optional_declaration_list  go to state 10
    declaration_list           go to state 11
    declaration                go to state 12
    var_declaration            go to state 13
    proc_declaration           go to state 14
    rec_declaration            go to state 15


State 7

   21 proc_declaration: A_PROCEDURE • A_NAME '(' optional_param_list ')' optional_return_type A_BEGIN optional_proc_decls_in_block stmt_list A_END

    A_NAME  shift, and go to state 16


State 8

   11 var_declaration: A_VAR • A_NAME ':' type_spec optional_assign_exp
   12                | A_VAR • A_NAME A_ASSIGN exp

    A_NAME  shift, and go to state 17


State 9

   35 rec_declaration: A_STRUCT • A_NAME '{' optional_rec_field_list '}'

    A_NAME  shift, and go to state 18


State 10

    3 program_prod: A_PROGRAM A_NAME A_BEGIN optional_declaration_list • A_END

    A_END  shift, and go to state 19


State 11

    5 optional_declaration_list: declaration_list •  [A_END, A_IN]
    7 declaration_list: declaration_list • ';' declaration

    ';'  shift, and go to state 20

    $default  reduce using rule 5 (optional_declaration_list)


State 12

    6 declaration_list: declaration •

    $default  reduce using rule 6 (declaration_list)


State 13

    8 declaration: var_declaration •

    $default  reduce using rule 8 (declaration)


State 14

    9 declaration: proc_declaration •

    $default  reduce using rule 9 (declaration)


State 15

   10 declaration: rec_declaration •

    $default  reduce using rule 10 (declaration)


State 16

   21 proc_declaration: A_PROCEDURE A_NAME • '(' optional_param_list ')' optional_return_type A_BEGIN optional_proc_decls_in_block stmt_list A_END

    '('  shift, and go to state 21


State 17

   11 var_declaration: A_VAR A_NAME • ':' type_spec optional_assign_exp
   12                | A_VAR A_NAME • A_ASSIGN exp

    ':'       shift, and go to state 22
    A_ASSIGN  shift, and go to state 23


State 18

   35 rec_declaration: A_STRUCT A_NAME • '{' optional_rec_field_list '}'

    '{'  shift, and go to state 24


State 19

    3 program_prod: A_PROGRAM A_NAME A_BEGIN optional_declaration_list A_END •

    $default  reduce using rule 3 (program_prod)


State 20

    7 declaration_list: declaration_list ';' • declaration
    8 declaration: • var_declaration
    9            | • proc_declaration
   10            | • rec_declaration
   11 var_declaration: • A_VAR A_NAME ':' type_spec optional_assign_exp
   12                | • A_VAR A_NAME A_ASSIGN exp
   21 proc_declaration: • A_PROCEDURE A_NAME '(' optional_param_list ')' optional_return_type A_BEGIN optional_proc_decls_in_block stmt_list A_END
   35 rec_declaration: • A_STRUCT A_NAME '{' optional_rec_field_list '}'

    A_PROCEDURE  shift, and go to state 7
    A_VAR        shift, and go to state 8
    A_STRUCT     shift, and go to state 9

    declaration       go to state 25
    var_declaration   go to state 13
    proc_declaration  go to state 14
    rec_declaration   go to state 15


State 21

   21 proc_declaration: A_PROCEDURE A_NAME '(' • optional_param_list ')' optional_return_type A_BEGIN optional_proc_decls_in_block stmt_list A_END
   22 optional_param_list: ε •  [')']
   23                    | • param_list
   24 param_list: • paramfield_decl
   25           | • param_list ',' paramfield_decl
   26 paramfield_decl: • A_NAME ':' type_spec

    A_NAME  shift, and go to state 26

    $default  reduce using rule 22 (optional_param_list)

    optional_param_list  go to state 27
    param_list           go to state 28
    paramfield_decl      go to state 29


State 22

   11 var_declaration: A_VAR A_NAME ':' • type_spec optional_assign_exp
   15 type_spec: • A_FLOAT
   16          | • A_INT
   17          | • A_STRING
   18          | • A_BOOL
   19          | • A_NAME
   20          | • A_REF '(' type_spec ')'

    A_NAME    shift, and go to state 30
    A_FLOAT   shift, and go to state 31
    A_INT     shift, and go to state 32
    A_STRING  shift, and go to state 33
    A_BOOL    shift, and go to state 34
    A_REF     shift, and go to state 35

    type_spec  go to state 36


State 23

   12 var_declaration: A_VAR A_NAME A_ASSIGN • exp
   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 49
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 24

   26 paramfield_decl: • A_NAME ':' type_spec
   35 rec_declaration: A_STRUCT A_NAME '{' • optional_rec_field_list '}'
   36 optional_rec_field_list: ε •  ['}']
   37                        | • rec_field_list
   38 rec_field_list: • paramfield_decl
   39               | • rec_field_list ';' paramfield_decl

    A_NAME  shift, and go to state 26

    $default  reduce using rule 36 (optional_rec_field_list)

    paramfield_decl          go to state 56
    optional_rec_field_list  go to state 57
    rec_field_list           go to state 58


State 25

    7 declaration_list: declaration_list ';' declaration •

    $default  reduce using rule 7 (declaration_list)


State 26

   26 paramfield_decl: A_NAME • ':' type_spec

    ':'  shift, and go to state 59


State 27

   21 proc_declaration: A_PROCEDURE A_NAME '(' optional_param_list • ')' optional_return_type A_BEGIN optional_proc_decls_in_block stmt_list A_END

    ')'  shift, and go to state 60


State 28

   23 optional_param_list: param_list •  [')']
   25 param_list: param_list • ',' paramfield_decl

    ','  shift, and go to state 61

    $default  reduce using rule 23 (optional_param_list)


State 29

   24 param_list: paramfield_decl •

    $default  reduce using rule 24 (param_list)


State 30

   19 type_spec: A_NAME •

    $default  reduce using rule 19 (type_spec)


State 31

   15 type_spec: A_FLOAT •

    $default  reduce using rule 15 (type_spec)


State 32

   16 type_spec: A_INT •

    $default  reduce using rule 16 (type_spec)


State 33

   17 type_spec: A_STRING •

    $default  reduce using rule 17 (type_spec)


State 34

   18 type_spec: A_BOOL •

    $default  reduce using rule 18 (type_spec)


State 35

   20 type_spec: A_REF • '(' type_spec ')'

    '('  shift, and go to state 62


State 36

   11 var_declaration: A_VAR A_NAME ':' type_spec • optional_assign_exp
   13 optional_assign_exp: ε •  [A_END, A_IN, ';']
   14                    | • A_ASSIGN exp

    A_ASSIGN  shift, and go to state 63

    $default  reduce using rule 13 (optional_assign_exp)

    optional_assign_exp  go to state 64


State 37

   67 literal: INT_LITERAL •

    $default  reduce using rule 67 (literal)


State 38

   66 literal: FLOAT_LITERAL •

    $default  reduce using rule 66 (literal)


State 39

   64 var_access: A_NAME •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', '<', '>', '=', '+', '-', '*', '/', '^', '.', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC, '|']
   99 call_stmt_as_exp: A_NAME • '(' optional_arg_list ')'

    '('  shift, and go to state 65

    $default  reduce using rule 64 (var_access)


State 40

   68 literal: STRING_LITERAL •

    $default  reduce using rule 68 (literal)


State 41

   71 bool_literal: A_TRUE •

    $default  reduce using rule 71 (bool_literal)


State 42

   72 bool_literal: A_FALSE •

    $default  reduce using rule 72 (bool_literal)


State 43

   70 literal: A_NULL •

    $default  reduce using rule 70 (literal)


State 44

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   47    | A_NOT • exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 66
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 45

   42 exp: A_NEW • A_NAME

    A_NAME  shift, and go to state 67


State 46

   61 ref_var: A_REF • '(' var_access ')'

    '('  shift, and go to state 68


State 47

   62 deref_var: A_DEREF • '(' var_access ')'
   63          | A_DEREF • '(' deref_var ')'

    '('  shift, and go to state 69


State 48

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   46    | '(' • exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 70
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 49

   12 var_declaration: A_VAR A_NAME A_ASSIGN exp •  [A_END, A_IN, ';']
   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84

    $default  reduce using rule 12 (var_declaration)


State 50

   44 exp: ref_var •

    $default  reduce using rule 44 (exp)


State 51

   45 exp: deref_var •

    $default  reduce using rule 45 (exp)


State 52

   43 exp: var_access •

    $default  reduce using rule 43 (exp)


State 53

   40 exp: literal •

    $default  reduce using rule 40 (exp)


State 54

   69 literal: bool_literal •

    $default  reduce using rule 69 (literal)


State 55

   41 exp: call_stmt_as_exp •

    $default  reduce using rule 41 (exp)


State 56

   38 rec_field_list: paramfield_decl •

    $default  reduce using rule 38 (rec_field_list)


State 57

   35 rec_declaration: A_STRUCT A_NAME '{' optional_rec_field_list • '}'

    '}'  shift, and go to state 85


State 58

   37 optional_rec_field_list: rec_field_list •  ['}']
   39 rec_field_list: rec_field_list • ';' paramfield_decl

    ';'  shift, and go to state 86

    $default  reduce using rule 37 (optional_rec_field_list)


State 59

   15 type_spec: • A_FLOAT
   16          | • A_INT
   17          | • A_STRING
   18          | • A_BOOL
   19          | • A_NAME
   20          | • A_REF '(' type_spec ')'
   26 paramfield_decl: A_NAME ':' • type_spec

    A_NAME    shift, and go to state 30
    A_FLOAT   shift, and go to state 31
    A_INT     shift, and go to state 32
    A_STRING  shift, and go to state 33
    A_BOOL    shift, and go to state 34
    A_REF     shift, and go to state 35

    type_spec  go to state 87


State 60

   21 proc_declaration: A_PROCEDURE A_NAME '(' optional_param_list ')' • optional_return_type A_BEGIN optional_proc_decls_in_block stmt_list A_END
   27 optional_return_type: ε •  [A_BEGIN]
   28                     | • ':' type_spec

    ':'  shift, and go to state 88

    $default  reduce using rule 27 (optional_return_type)

    optional_return_type  go to state 89


State 61

   25 param_list: param_list ',' • paramfield_decl
   26 paramfield_decl: • A_NAME ':' type_spec

    A_NAME  shift, and go to state 26

    paramfield_decl  go to state 90


State 62

   15 type_spec: • A_FLOAT
   16          | • A_INT
   17          | • A_STRING
   18          | • A_BOOL
   19          | • A_NAME
   20          | • A_REF '(' type_spec ')'
   20          | A_REF '(' • type_spec ')'

    A_NAME    shift, and go to state 30
    A_FLOAT   shift, and go to state 31
    A_INT     shift, and go to state 32
    A_STRING  shift, and go to state 33
    A_BOOL    shift, and go to state 34
    A_REF     shift, and go to state 35

    type_spec  go to state 91


State 63

   14 optional_assign_exp: A_ASSIGN • exp
   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 92
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 64

   11 var_declaration: A_VAR A_NAME ':' type_spec optional_assign_exp •

    $default  reduce using rule 11 (var_declaration)


State 65

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'
   99                 | A_NAME '(' • optional_arg_list ')'
  100 optional_arg_list: ε •  [')']
  101                  | • arg_list
  102 arg_list: • exp
  103         | • arg_list ',' exp

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    $default  reduce using rule 100 (optional_arg_list)

    exp                go to state 93
    ref_var            go to state 50
    deref_var          go to state 51
    var_access         go to state 52
    literal            go to state 53
    bool_literal       go to state 54
    call_stmt_as_exp   go to state 55
    optional_arg_list  go to state 94
    arg_list           go to state 95


State 66

   47 exp: A_NOT exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', '<', '>', '=', '+', '-', '*', '/', '^', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC, '|']
   48    | exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '.'  shift, and go to state 79

    $default  reduce using rule 47 (exp)

    Conflict between rule 47 and token '<' resolved as reduce ('<' < A_NOT).
    Conflict between rule 47 and token '>' resolved as reduce ('>' < A_NOT).
    Conflict between rule 47 and token '=' resolved as reduce ('=' < A_NOT).
    Conflict between rule 47 and token '+' resolved as reduce ('+' < A_NOT).
    Conflict between rule 47 and token '-' resolved as reduce ('-' < A_NOT).
    Conflict between rule 47 and token '*' resolved as reduce ('*' < A_NOT).
    Conflict between rule 47 and token '/' resolved as reduce ('/' < A_NOT).
    Conflict between rule 47 and token '^' resolved as reduce ('^' < A_NOT).
    Conflict between rule 47 and token '.' resolved as shift (A_NOT < '.').
    Conflict between rule 47 and token A_LESS_THAN_EQUAL resolved as reduce (A_LESS_THAN_EQUAL < A_NOT).
    Conflict between rule 47 and token A_GREATER_THAN_EQUAL resolved as reduce (A_GREATER_THAN_EQUAL < A_NOT).
    Conflict between rule 47 and token A_DIFFERENT resolved as reduce (A_DIFFERENT < A_NOT).
    Conflict between rule 47 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < A_NOT).
    Conflict between rule 47 and token A_AND_LOGIC resolved as reduce (A_AND_LOGIC < A_NOT).


State 67

   42 exp: A_NEW A_NAME •

    $default  reduce using rule 42 (exp)


State 68

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   61        | A_REF '(' • var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 96
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 97
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 69

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   62          | A_DEREF '(' • var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   63          | A_DEREF '(' • deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 96
    ref_var           go to state 50
    deref_var         go to state 98
    var_access        go to state 99
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 70

   46 exp: '(' exp • ')'
   48    | exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    ')'                   shift, and go to state 100
    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84


State 71

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   50    | exp '<' • exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 101
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 72

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   52    | exp '>' • exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 102
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 73

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   54    | exp '=' • exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 103
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 74

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   56    | exp '+' • exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 104
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 75

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   57    | exp '-' • exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 105
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 76

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   58    | exp '*' • exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 106
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 77

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   59    | exp '/' • exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 107
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 78

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   60    | exp '^' • exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 108
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 79

   65 var_access: exp '.' • A_NAME

    A_NAME  shift, and go to state 109


State 80

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   51    | exp A_LESS_THAN_EQUAL • exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 110
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 81

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   53    | exp A_GREATER_THAN_EQUAL • exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 111
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 82

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   55    | exp A_DIFFERENT • exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 112
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 83

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   48    | exp A_OR_LOGIC • exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 113
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 84

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   49    | exp A_AND_LOGIC • exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 114
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 85

   35 rec_declaration: A_STRUCT A_NAME '{' optional_rec_field_list '}' •

    $default  reduce using rule 35 (rec_declaration)


State 86

   26 paramfield_decl: • A_NAME ':' type_spec
   39 rec_field_list: rec_field_list ';' • paramfield_decl

    A_NAME  shift, and go to state 26

    paramfield_decl  go to state 115


State 87

   26 paramfield_decl: A_NAME ':' type_spec •

    $default  reduce using rule 26 (paramfield_decl)


State 88

   15 type_spec: • A_FLOAT
   16          | • A_INT
   17          | • A_STRING
   18          | • A_BOOL
   19          | • A_NAME
   20          | • A_REF '(' type_spec ')'
   28 optional_return_type: ':' • type_spec

    A_NAME    shift, and go to state 30
    A_FLOAT   shift, and go to state 31
    A_INT     shift, and go to state 32
    A_STRING  shift, and go to state 33
    A_BOOL    shift, and go to state 34
    A_REF     shift, and go to state 35

    type_spec  go to state 116


State 89

   21 proc_declaration: A_PROCEDURE A_NAME '(' optional_param_list ')' optional_return_type • A_BEGIN optional_proc_decls_in_block stmt_list A_END

    A_BEGIN  shift, and go to state 117


State 90

   25 param_list: param_list ',' paramfield_decl •

    $default  reduce using rule 25 (param_list)


State 91

   20 type_spec: A_REF '(' type_spec • ')'

    ')'  shift, and go to state 118


State 92

   14 optional_assign_exp: A_ASSIGN exp •  [A_END, A_IN, ';']
   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84

    $default  reduce using rule 14 (optional_assign_exp)


State 93

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME
  102 arg_list: exp •  [',', ')']

    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84

    $default  reduce using rule 102 (arg_list)


State 94

   99 call_stmt_as_exp: A_NAME '(' optional_arg_list • ')'

    ')'  shift, and go to state 119


State 95

  101 optional_arg_list: arg_list •  [')']
  103 arg_list: arg_list • ',' exp

    ','  shift, and go to state 120

    $default  reduce using rule 101 (optional_arg_list)


State 96

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84


State 97

   43 exp: var_access •  ['<', '>', '=', '+', '-', '*', '/', '^', '.', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC]
   61 ref_var: A_REF '(' var_access • ')'

    ')'  shift, and go to state 121

    $default  reduce using rule 43 (exp)


State 98

   45 exp: deref_var •  ['<', '>', '=', '+', '-', '*', '/', '^', '.', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC]
   63 deref_var: A_DEREF '(' deref_var • ')'

    ')'  shift, and go to state 122

    $default  reduce using rule 45 (exp)


State 99

   43 exp: var_access •  ['<', '>', '=', '+', '-', '*', '/', '^', '.', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC]
   62 deref_var: A_DEREF '(' var_access • ')'

    ')'  shift, and go to state 123

    $default  reduce using rule 43 (exp)


State 100

   46 exp: '(' exp ')' •

    $default  reduce using rule 46 (exp)


State 101

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   50    | exp '<' exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', A_OR_LOGIC, A_AND_LOGIC, '|']
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '+'  shift, and go to state 74
    '-'  shift, and go to state 75
    '*'  shift, and go to state 76
    '/'  shift, and go to state 77
    '^'  shift, and go to state 78
    '.'  shift, and go to state 79

    '<'                   error (nonassociative)
    '>'                   error (nonassociative)
    '='                   error (nonassociative)
    A_LESS_THAN_EQUAL     error (nonassociative)
    A_GREATER_THAN_EQUAL  error (nonassociative)
    A_DIFFERENT           error (nonassociative)

    $default  reduce using rule 50 (exp)

    Conflict between rule 50 and token '<' resolved as an error (%nonassoc '<').
    Conflict between rule 50 and token '>' resolved as an error (%nonassoc '>').
    Conflict between rule 50 and token '=' resolved as an error (%nonassoc '=').
    Conflict between rule 50 and token '+' resolved as shift ('<' < '+').
    Conflict between rule 50 and token '-' resolved as shift ('<' < '-').
    Conflict between rule 50 and token '*' resolved as shift ('<' < '*').
    Conflict between rule 50 and token '/' resolved as shift ('<' < '/').
    Conflict between rule 50 and token '^' resolved as shift ('<' < '^').
    Conflict between rule 50 and token '.' resolved as shift ('<' < '.').
    Conflict between rule 50 and token A_LESS_THAN_EQUAL resolved as an error (%nonassoc A_LESS_THAN_EQUAL).
    Conflict between rule 50 and token A_GREATER_THAN_EQUAL resolved as an error (%nonassoc A_GREATER_THAN_EQUAL).
    Conflict between rule 50 and token A_DIFFERENT resolved as an error (%nonassoc A_DIFFERENT).
    Conflict between rule 50 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < '<').
    Conflict between rule 50 and token A_AND_LOGIC resolved as reduce (A_AND_LOGIC < '<').


State 102

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   52    | exp '>' exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', A_OR_LOGIC, A_AND_LOGIC, '|']
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '+'  shift, and go to state 74
    '-'  shift, and go to state 75
    '*'  shift, and go to state 76
    '/'  shift, and go to state 77
    '^'  shift, and go to state 78
    '.'  shift, and go to state 79

    '<'                   error (nonassociative)
    '>'                   error (nonassociative)
    '='                   error (nonassociative)
    A_LESS_THAN_EQUAL     error (nonassociative)
    A_GREATER_THAN_EQUAL  error (nonassociative)
    A_DIFFERENT           error (nonassociative)

    $default  reduce using rule 52 (exp)

    Conflict between rule 52 and token '<' resolved as an error (%nonassoc '<').
    Conflict between rule 52 and token '>' resolved as an error (%nonassoc '>').
    Conflict between rule 52 and token '=' resolved as an error (%nonassoc '=').
    Conflict between rule 52 and token '+' resolved as shift ('>' < '+').
    Conflict between rule 52 and token '-' resolved as shift ('>' < '-').
    Conflict between rule 52 and token '*' resolved as shift ('>' < '*').
    Conflict between rule 52 and token '/' resolved as shift ('>' < '/').
    Conflict between rule 52 and token '^' resolved as shift ('>' < '^').
    Conflict between rule 52 and token '.' resolved as shift ('>' < '.').
    Conflict between rule 52 and token A_LESS_THAN_EQUAL resolved as an error (%nonassoc A_LESS_THAN_EQUAL).
    Conflict between rule 52 and token A_GREATER_THAN_EQUAL resolved as an error (%nonassoc A_GREATER_THAN_EQUAL).
    Conflict between rule 52 and token A_DIFFERENT resolved as an error (%nonassoc A_DIFFERENT).
    Conflict between rule 52 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < '>').
    Conflict between rule 52 and token A_AND_LOGIC resolved as reduce (A_AND_LOGIC < '>').


State 103

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   54    | exp '=' exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', A_OR_LOGIC, A_AND_LOGIC, '|']
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '+'  shift, and go to state 74
    '-'  shift, and go to state 75
    '*'  shift, and go to state 76
    '/'  shift, and go to state 77
    '^'  shift, and go to state 78
    '.'  shift, and go to state 79

    '<'                   error (nonassociative)
    '>'                   error (nonassociative)
    '='                   error (nonassociative)
    A_LESS_THAN_EQUAL     error (nonassociative)
    A_GREATER_THAN_EQUAL  error (nonassociative)
    A_DIFFERENT           error (nonassociative)

    $default  reduce using rule 54 (exp)

    Conflict between rule 54 and token '<' resolved as an error (%nonassoc '<').
    Conflict between rule 54 and token '>' resolved as an error (%nonassoc '>').
    Conflict between rule 54 and token '=' resolved as an error (%nonassoc '=').
    Conflict between rule 54 and token '+' resolved as shift ('=' < '+').
    Conflict between rule 54 and token '-' resolved as shift ('=' < '-').
    Conflict between rule 54 and token '*' resolved as shift ('=' < '*').
    Conflict between rule 54 and token '/' resolved as shift ('=' < '/').
    Conflict between rule 54 and token '^' resolved as shift ('=' < '^').
    Conflict between rule 54 and token '.' resolved as shift ('=' < '.').
    Conflict between rule 54 and token A_LESS_THAN_EQUAL resolved as an error (%nonassoc A_LESS_THAN_EQUAL).
    Conflict between rule 54 and token A_GREATER_THAN_EQUAL resolved as an error (%nonassoc A_GREATER_THAN_EQUAL).
    Conflict between rule 54 and token A_DIFFERENT resolved as an error (%nonassoc A_DIFFERENT).
    Conflict between rule 54 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < '=').
    Conflict between rule 54 and token A_AND_LOGIC resolved as reduce (A_AND_LOGIC < '=').


State 104

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   56    | exp '+' exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', '<', '>', '=', '+', '-', '*', '/', '^', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC, '|']
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '.'  shift, and go to state 79

    $default  reduce using rule 56 (exp)

    Conflict between rule 56 and token '<' resolved as reduce ('<' < A_U_PLUS).
    Conflict between rule 56 and token '>' resolved as reduce ('>' < A_U_PLUS).
    Conflict between rule 56 and token '=' resolved as reduce ('=' < A_U_PLUS).
    Conflict between rule 56 and token '+' resolved as reduce ('+' < A_U_PLUS).
    Conflict between rule 56 and token '-' resolved as reduce ('-' < A_U_PLUS).
    Conflict between rule 56 and token '*' resolved as reduce ('*' < A_U_PLUS).
    Conflict between rule 56 and token '/' resolved as reduce ('/' < A_U_PLUS).
    Conflict between rule 56 and token '^' resolved as reduce ('^' < A_U_PLUS).
    Conflict between rule 56 and token '.' resolved as shift (A_U_PLUS < '.').
    Conflict between rule 56 and token A_LESS_THAN_EQUAL resolved as reduce (A_LESS_THAN_EQUAL < A_U_PLUS).
    Conflict between rule 56 and token A_GREATER_THAN_EQUAL resolved as reduce (A_GREATER_THAN_EQUAL < A_U_PLUS).
    Conflict between rule 56 and token A_DIFFERENT resolved as reduce (A_DIFFERENT < A_U_PLUS).
    Conflict between rule 56 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < A_U_PLUS).
    Conflict between rule 56 and token A_AND_LOGIC resolved as reduce (A_AND_LOGIC < A_U_PLUS).


State 105

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   57    | exp '-' exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', '<', '>', '=', '+', '-', '*', '/', '^', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC, '|']
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '.'  shift, and go to state 79

    $default  reduce using rule 57 (exp)

    Conflict between rule 57 and token '<' resolved as reduce ('<' < A_U_MINUS).
    Conflict between rule 57 and token '>' resolved as reduce ('>' < A_U_MINUS).
    Conflict between rule 57 and token '=' resolved as reduce ('=' < A_U_MINUS).
    Conflict between rule 57 and token '+' resolved as reduce ('+' < A_U_MINUS).
    Conflict between rule 57 and token '-' resolved as reduce ('-' < A_U_MINUS).
    Conflict between rule 57 and token '*' resolved as reduce ('*' < A_U_MINUS).
    Conflict between rule 57 and token '/' resolved as reduce ('/' < A_U_MINUS).
    Conflict between rule 57 and token '^' resolved as reduce ('^' < A_U_MINUS).
    Conflict between rule 57 and token '.' resolved as shift (A_U_MINUS < '.').
    Conflict between rule 57 and token A_LESS_THAN_EQUAL resolved as reduce (A_LESS_THAN_EQUAL < A_U_MINUS).
    Conflict between rule 57 and token A_GREATER_THAN_EQUAL resolved as reduce (A_GREATER_THAN_EQUAL < A_U_MINUS).
    Conflict between rule 57 and token A_DIFFERENT resolved as reduce (A_DIFFERENT < A_U_MINUS).
    Conflict between rule 57 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < A_U_MINUS).
    Conflict between rule 57 and token A_AND_LOGIC resolved as reduce (A_AND_LOGIC < A_U_MINUS).


State 106

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   58    | exp '*' exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', '<', '>', '=', '+', '-', '*', '/', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC, '|']
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '^'  shift, and go to state 78
    '.'  shift, and go to state 79

    $default  reduce using rule 58 (exp)

    Conflict between rule 58 and token '<' resolved as reduce ('<' < '*').
    Conflict between rule 58 and token '>' resolved as reduce ('>' < '*').
    Conflict between rule 58 and token '=' resolved as reduce ('=' < '*').
    Conflict between rule 58 and token '+' resolved as reduce ('+' < '*').
    Conflict between rule 58 and token '-' resolved as reduce ('-' < '*').
    Conflict between rule 58 and token '*' resolved as reduce (%left '*').
    Conflict between rule 58 and token '/' resolved as reduce (%left '/').
    Conflict between rule 58 and token '^' resolved as shift ('*' < '^').
    Conflict between rule 58 and token '.' resolved as shift ('*' < '.').
    Conflict between rule 58 and token A_LESS_THAN_EQUAL resolved as reduce (A_LESS_THAN_EQUAL < '*').
    Conflict between rule 58 and token A_GREATER_THAN_EQUAL resolved as reduce (A_GREATER_THAN_EQUAL < '*').
    Conflict between rule 58 and token A_DIFFERENT resolved as reduce (A_DIFFERENT < '*').
    Conflict between rule 58 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < '*').
    Conflict between rule 58 and token A_AND_LOGIC resolved as reduce (A_AND_LOGIC < '*').


State 107

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   59    | exp '/' exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', '<', '>', '=', '+', '-', '*', '/', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC, '|']
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '^'  shift, and go to state 78
    '.'  shift, and go to state 79

    $default  reduce using rule 59 (exp)

    Conflict between rule 59 and token '<' resolved as reduce ('<' < '/').
    Conflict between rule 59 and token '>' resolved as reduce ('>' < '/').
    Conflict between rule 59 and token '=' resolved as reduce ('=' < '/').
    Conflict between rule 59 and token '+' resolved as reduce ('+' < '/').
    Conflict between rule 59 and token '-' resolved as reduce ('-' < '/').
    Conflict between rule 59 and token '*' resolved as reduce (%left '*').
    Conflict between rule 59 and token '/' resolved as reduce (%left '/').
    Conflict between rule 59 and token '^' resolved as shift ('/' < '^').
    Conflict between rule 59 and token '.' resolved as shift ('/' < '.').
    Conflict between rule 59 and token A_LESS_THAN_EQUAL resolved as reduce (A_LESS_THAN_EQUAL < '/').
    Conflict between rule 59 and token A_GREATER_THAN_EQUAL resolved as reduce (A_GREATER_THAN_EQUAL < '/').
    Conflict between rule 59 and token A_DIFFERENT resolved as reduce (A_DIFFERENT < '/').
    Conflict between rule 59 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < '/').
    Conflict between rule 59 and token A_AND_LOGIC resolved as reduce (A_AND_LOGIC < '/').


State 108

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   60    | exp '^' exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', '<', '>', '=', '+', '-', '*', '/', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC, '|']
   65 var_access: exp • '.' A_NAME

    '^'  shift, and go to state 78
    '.'  shift, and go to state 79

    $default  reduce using rule 60 (exp)

    Conflict between rule 60 and token '<' resolved as reduce ('<' < '^').
    Conflict between rule 60 and token '>' resolved as reduce ('>' < '^').
    Conflict between rule 60 and token '=' resolved as reduce ('=' < '^').
    Conflict between rule 60 and token '+' resolved as reduce ('+' < '^').
    Conflict between rule 60 and token '-' resolved as reduce ('-' < '^').
    Conflict between rule 60 and token '*' resolved as reduce ('*' < '^').
    Conflict between rule 60 and token '/' resolved as reduce ('/' < '^').
    Conflict between rule 60 and token '^' resolved as shift (%right '^').
    Conflict between rule 60 and token '.' resolved as shift ('^' < '.').
    Conflict between rule 60 and token A_LESS_THAN_EQUAL resolved as reduce (A_LESS_THAN_EQUAL < '^').
    Conflict between rule 60 and token A_GREATER_THAN_EQUAL resolved as reduce (A_GREATER_THAN_EQUAL < '^').
    Conflict between rule 60 and token A_DIFFERENT resolved as reduce (A_DIFFERENT < '^').
    Conflict between rule 60 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < '^').
    Conflict between rule 60 and token A_AND_LOGIC resolved as reduce (A_AND_LOGIC < '^').


State 109

   65 var_access: exp '.' A_NAME •

    $default  reduce using rule 65 (var_access)


State 110

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   51    | exp A_LESS_THAN_EQUAL exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', A_OR_LOGIC, A_AND_LOGIC, '|']
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '+'  shift, and go to state 74
    '-'  shift, and go to state 75
    '*'  shift, and go to state 76
    '/'  shift, and go to state 77
    '^'  shift, and go to state 78
    '.'  shift, and go to state 79

    '<'                   error (nonassociative)
    '>'                   error (nonassociative)
    '='                   error (nonassociative)
    A_LESS_THAN_EQUAL     error (nonassociative)
    A_GREATER_THAN_EQUAL  error (nonassociative)
    A_DIFFERENT           error (nonassociative)

    $default  reduce using rule 51 (exp)

    Conflict between rule 51 and token '<' resolved as an error (%nonassoc '<').
    Conflict between rule 51 and token '>' resolved as an error (%nonassoc '>').
    Conflict between rule 51 and token '=' resolved as an error (%nonassoc '=').
    Conflict between rule 51 and token '+' resolved as shift (A_LESS_THAN_EQUAL < '+').
    Conflict between rule 51 and token '-' resolved as shift (A_LESS_THAN_EQUAL < '-').
    Conflict between rule 51 and token '*' resolved as shift (A_LESS_THAN_EQUAL < '*').
    Conflict between rule 51 and token '/' resolved as shift (A_LESS_THAN_EQUAL < '/').
    Conflict between rule 51 and token '^' resolved as shift (A_LESS_THAN_EQUAL < '^').
    Conflict between rule 51 and token '.' resolved as shift (A_LESS_THAN_EQUAL < '.').
    Conflict between rule 51 and token A_LESS_THAN_EQUAL resolved as an error (%nonassoc A_LESS_THAN_EQUAL).
    Conflict between rule 51 and token A_GREATER_THAN_EQUAL resolved as an error (%nonassoc A_GREATER_THAN_EQUAL).
    Conflict between rule 51 and token A_DIFFERENT resolved as an error (%nonassoc A_DIFFERENT).
    Conflict between rule 51 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < A_LESS_THAN_EQUAL).
    Conflict between rule 51 and token A_AND_LOGIC resolved as reduce (A_AND_LOGIC < A_LESS_THAN_EQUAL).


State 111

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   53    | exp A_GREATER_THAN_EQUAL exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', A_OR_LOGIC, A_AND_LOGIC, '|']
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '+'  shift, and go to state 74
    '-'  shift, and go to state 75
    '*'  shift, and go to state 76
    '/'  shift, and go to state 77
    '^'  shift, and go to state 78
    '.'  shift, and go to state 79

    '<'                   error (nonassociative)
    '>'                   error (nonassociative)
    '='                   error (nonassociative)
    A_LESS_THAN_EQUAL     error (nonassociative)
    A_GREATER_THAN_EQUAL  error (nonassociative)
    A_DIFFERENT           error (nonassociative)

    $default  reduce using rule 53 (exp)

    Conflict between rule 53 and token '<' resolved as an error (%nonassoc '<').
    Conflict between rule 53 and token '>' resolved as an error (%nonassoc '>').
    Conflict between rule 53 and token '=' resolved as an error (%nonassoc '=').
    Conflict between rule 53 and token '+' resolved as shift (A_GREATER_THAN_EQUAL < '+').
    Conflict between rule 53 and token '-' resolved as shift (A_GREATER_THAN_EQUAL < '-').
    Conflict between rule 53 and token '*' resolved as shift (A_GREATER_THAN_EQUAL < '*').
    Conflict between rule 53 and token '/' resolved as shift (A_GREATER_THAN_EQUAL < '/').
    Conflict between rule 53 and token '^' resolved as shift (A_GREATER_THAN_EQUAL < '^').
    Conflict between rule 53 and token '.' resolved as shift (A_GREATER_THAN_EQUAL < '.').
    Conflict between rule 53 and token A_LESS_THAN_EQUAL resolved as an error (%nonassoc A_LESS_THAN_EQUAL).
    Conflict between rule 53 and token A_GREATER_THAN_EQUAL resolved as an error (%nonassoc A_GREATER_THAN_EQUAL).
    Conflict between rule 53 and token A_DIFFERENT resolved as an error (%nonassoc A_DIFFERENT).
    Conflict between rule 53 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < A_GREATER_THAN_EQUAL).
    Conflict between rule 53 and token A_AND_LOGIC resolved as reduce (A_AND_LOGIC < A_GREATER_THAN_EQUAL).


State 112

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   55    | exp A_DIFFERENT exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', A_OR_LOGIC, A_AND_LOGIC, '|']
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '+'  shift, and go to state 74
    '-'  shift, and go to state 75
    '*'  shift, and go to state 76
    '/'  shift, and go to state 77
    '^'  shift, and go to state 78
    '.'  shift, and go to state 79

    '<'                   error (nonassociative)
    '>'                   error (nonassociative)
    '='                   error (nonassociative)
    A_LESS_THAN_EQUAL     error (nonassociative)
    A_GREATER_THAN_EQUAL  error (nonassociative)
    A_DIFFERENT           error (nonassociative)

    $default  reduce using rule 55 (exp)

    Conflict between rule 55 and token '<' resolved as an error (%nonassoc '<').
    Conflict between rule 55 and token '>' resolved as an error (%nonassoc '>').
    Conflict between rule 55 and token '=' resolved as an error (%nonassoc '=').
    Conflict between rule 55 and token '+' resolved as shift (A_DIFFERENT < '+').
    Conflict between rule 55 and token '-' resolved as shift (A_DIFFERENT < '-').
    Conflict between rule 55 and token '*' resolved as shift (A_DIFFERENT < '*').
    Conflict between rule 55 and token '/' resolved as shift (A_DIFFERENT < '/').
    Conflict between rule 55 and token '^' resolved as shift (A_DIFFERENT < '^').
    Conflict between rule 55 and token '.' resolved as shift (A_DIFFERENT < '.').
    Conflict between rule 55 and token A_LESS_THAN_EQUAL resolved as an error (%nonassoc A_LESS_THAN_EQUAL).
    Conflict between rule 55 and token A_GREATER_THAN_EQUAL resolved as an error (%nonassoc A_GREATER_THAN_EQUAL).
    Conflict between rule 55 and token A_DIFFERENT resolved as an error (%nonassoc A_DIFFERENT).
    Conflict between rule 55 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < A_DIFFERENT).
    Conflict between rule 55 and token A_AND_LOGIC resolved as reduce (A_AND_LOGIC < A_DIFFERENT).


State 113

   48 exp: exp • A_OR_LOGIC exp
   48    | exp A_OR_LOGIC exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', A_OR_LOGIC, '|']
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_AND_LOGIC           shift, and go to state 84

    $default  reduce using rule 48 (exp)

    Conflict between rule 48 and token '<' resolved as shift (A_OR_LOGIC < '<').
    Conflict between rule 48 and token '>' resolved as shift (A_OR_LOGIC < '>').
    Conflict between rule 48 and token '=' resolved as shift (A_OR_LOGIC < '=').
    Conflict between rule 48 and token '+' resolved as shift (A_OR_LOGIC < '+').
    Conflict between rule 48 and token '-' resolved as shift (A_OR_LOGIC < '-').
    Conflict between rule 48 and token '*' resolved as shift (A_OR_LOGIC < '*').
    Conflict between rule 48 and token '/' resolved as shift (A_OR_LOGIC < '/').
    Conflict between rule 48 and token '^' resolved as shift (A_OR_LOGIC < '^').
    Conflict between rule 48 and token '.' resolved as shift (A_OR_LOGIC < '.').
    Conflict between rule 48 and token A_LESS_THAN_EQUAL resolved as shift (A_OR_LOGIC < A_LESS_THAN_EQUAL).
    Conflict between rule 48 and token A_GREATER_THAN_EQUAL resolved as shift (A_OR_LOGIC < A_GREATER_THAN_EQUAL).
    Conflict between rule 48 and token A_DIFFERENT resolved as shift (A_OR_LOGIC < A_DIFFERENT).
    Conflict between rule 48 and token A_OR_LOGIC resolved as reduce (%left A_OR_LOGIC).
    Conflict between rule 48 and token A_AND_LOGIC resolved as shift (A_OR_LOGIC < A_AND_LOGIC).


State 114

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   49    | exp A_AND_LOGIC exp •  [A_END, A_THEN, A_ELSE, A_FI, A_DO, A_OD, A_OF, A_ESAC, A_OTHERWISE, A_IN, ';', ',', ')', A_OR_LOGIC, A_AND_LOGIC, '|']
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME

    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82

    $default  reduce using rule 49 (exp)

    Conflict between rule 49 and token '<' resolved as shift (A_AND_LOGIC < '<').
    Conflict between rule 49 and token '>' resolved as shift (A_AND_LOGIC < '>').
    Conflict between rule 49 and token '=' resolved as shift (A_AND_LOGIC < '=').
    Conflict between rule 49 and token '+' resolved as shift (A_AND_LOGIC < '+').
    Conflict between rule 49 and token '-' resolved as shift (A_AND_LOGIC < '-').
    Conflict between rule 49 and token '*' resolved as shift (A_AND_LOGIC < '*').
    Conflict between rule 49 and token '/' resolved as shift (A_AND_LOGIC < '/').
    Conflict between rule 49 and token '^' resolved as shift (A_AND_LOGIC < '^').
    Conflict between rule 49 and token '.' resolved as shift (A_AND_LOGIC < '.').
    Conflict between rule 49 and token A_LESS_THAN_EQUAL resolved as shift (A_AND_LOGIC < A_LESS_THAN_EQUAL).
    Conflict between rule 49 and token A_GREATER_THAN_EQUAL resolved as shift (A_AND_LOGIC < A_GREATER_THAN_EQUAL).
    Conflict between rule 49 and token A_DIFFERENT resolved as shift (A_AND_LOGIC < A_DIFFERENT).
    Conflict between rule 49 and token A_OR_LOGIC resolved as reduce (A_OR_LOGIC < A_AND_LOGIC).
    Conflict between rule 49 and token A_AND_LOGIC resolved as reduce (%left A_AND_LOGIC).


State 115

   39 rec_field_list: rec_field_list ';' paramfield_decl •

    $default  reduce using rule 39 (rec_field_list)


State 116

   28 optional_return_type: ':' type_spec •

    $default  reduce using rule 28 (optional_return_type)


State 117

    4 optional_declaration_list: ε •  [A_IN]
    5                          | • declaration_list
    6 declaration_list: • declaration
    7                 | • declaration_list ';' declaration
    8 declaration: • var_declaration
    9            | • proc_declaration
   10            | • rec_declaration
   11 var_declaration: • A_VAR A_NAME ':' type_spec optional_assign_exp
   12                | • A_VAR A_NAME A_ASSIGN exp
   21 proc_declaration: • A_PROCEDURE A_NAME '(' optional_param_list ')' optional_return_type A_BEGIN optional_proc_decls_in_block stmt_list A_END
   21                 | A_PROCEDURE A_NAME '(' optional_param_list ')' optional_return_type A_BEGIN • optional_proc_decls_in_block stmt_list A_END
   29 optional_proc_decls_in_block: ε •  [INT_LITERAL, FLOAT_LITERAL, A_NAME, STRING_LITERAL, A_END, A_IF, A_WHILE, A_RETURN, A_UNLESS, A_CASE, A_TRUE, A_FALSE, A_NULL, A_NOT, A_NEW, A_REF, A_DEREF, '(']
   30                             | • optional_declaration_list A_IN
   35 rec_declaration: • A_STRUCT A_NAME '{' optional_rec_field_list '}'

    A_PROCEDURE  shift, and go to state 7
    A_VAR        shift, and go to state 8
    A_STRUCT     shift, and go to state 9

    A_IN      reduce using rule 4 (optional_declaration_list)
    $default  reduce using rule 29 (optional_proc_decls_in_block)

    optional_declaration_list     go to state 124
    declaration_list              go to state 11
    declaration                   go to state 12
    var_declaration               go to state 13
    proc_declaration              go to state 14
    optional_proc_decls_in_block  go to state 125
    rec_declaration               go to state 15


State 118

   20 type_spec: A_REF '(' type_spec ')' •

    $default  reduce using rule 20 (type_spec)


State 119

   99 call_stmt_as_exp: A_NAME '(' optional_arg_list ')' •

    $default  reduce using rule 99 (call_stmt_as_exp)


State 120

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'
  103 arg_list: arg_list ',' • exp

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 126
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 121

   61 ref_var: A_REF '(' var_access ')' •

    $default  reduce using rule 61 (ref_var)


State 122

   63 deref_var: A_DEREF '(' deref_var ')' •

    $default  reduce using rule 63 (deref_var)


State 123

   62 deref_var: A_DEREF '(' var_access ')' •

    $default  reduce using rule 62 (deref_var)


State 124

   30 optional_proc_decls_in_block: optional_declaration_list • A_IN

    A_IN  shift, and go to state 127


State 125

   21 proc_declaration: A_PROCEDURE A_NAME '(' optional_param_list ')' optional_return_type A_BEGIN optional_proc_decls_in_block • stmt_list A_END
   31 stmt_list: ε •  [A_END]
   32          | • stmt_sequence
   33 stmt_sequence: • stmt
   34              | • stmt ';' stmt_sequence
   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   73 stmt: • assign_stmt
   74     | • if_stmt
   75     | • while_stmt
   76     | • return_stmt
   77     | • call_stmt
   78 assign_stmt: • var_access A_ASSIGN exp
   79            | • deref_var A_ASSIGN exp
   80 if_stmt: • A_IF exp A_THEN stmt_list optional_else_clause A_FI
   81        | • A_UNLESS exp A_DO stmt_list optional_else_clause A_OD
   82        | • A_CASE exp A_OF case_list optional_otherwise_clause A_ESAC
   94 while_stmt: • A_WHILE exp A_DO stmt_list A_OD
   95 return_stmt: • A_RETURN optional_exp_val
   98 call_stmt: • A_NAME '(' optional_arg_list ')'
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 128
    STRING_LITERAL  shift, and go to state 40
    A_IF            shift, and go to state 129
    A_WHILE         shift, and go to state 130
    A_RETURN        shift, and go to state 131
    A_UNLESS        shift, and go to state 132
    A_CASE          shift, and go to state 133
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    $default  reduce using rule 31 (stmt_list)

    stmt_list         go to state 134
    stmt_sequence     go to state 135
    exp               go to state 96
    ref_var           go to state 50
    deref_var         go to state 136
    var_access        go to state 137
    literal           go to state 53
    bool_literal      go to state 54
    stmt              go to state 138
    assign_stmt       go to state 139
    if_stmt           go to state 140
    while_stmt        go to state 141
    return_stmt       go to state 142
    call_stmt         go to state 143
    call_stmt_as_exp  go to state 55


State 126

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME
  103 arg_list: arg_list ',' exp •  [',', ')']

    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84

    $default  reduce using rule 103 (arg_list)


State 127

   30 optional_proc_decls_in_block: optional_declaration_list A_IN •

    $default  reduce using rule 30 (optional_proc_decls_in_block)


State 128

   64 var_access: A_NAME •  ['<', '>', '=', '+', '-', '*', '/', '^', '.', A_ASSIGN, A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC]
   98 call_stmt: A_NAME • '(' optional_arg_list ')'
   99 call_stmt_as_exp: A_NAME • '(' optional_arg_list ')'

    '('  shift, and go to state 144

    $default  reduce using rule 64 (var_access)


State 129

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   80 if_stmt: A_IF • exp A_THEN stmt_list optional_else_clause A_FI
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 145
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 130

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   94 while_stmt: A_WHILE • exp A_DO stmt_list A_OD
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 146
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 131

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   95 return_stmt: A_RETURN • optional_exp_val
   96 optional_exp_val: ε •  [A_END, A_ELSE, A_FI, A_OD, A_ESAC, A_OTHERWISE, ';', '|']
   97                 | • exp
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    $default  reduce using rule 96 (optional_exp_val)

    exp               go to state 147
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    optional_exp_val  go to state 148
    call_stmt_as_exp  go to state 55


State 132

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   81 if_stmt: A_UNLESS • exp A_DO stmt_list optional_else_clause A_OD
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 149
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 133

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   82 if_stmt: A_CASE • exp A_OF case_list optional_otherwise_clause A_ESAC
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 150
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 134

   21 proc_declaration: A_PROCEDURE A_NAME '(' optional_param_list ')' optional_return_type A_BEGIN optional_proc_decls_in_block stmt_list • A_END

    A_END  shift, and go to state 151


State 135

   32 stmt_list: stmt_sequence •

    $default  reduce using rule 32 (stmt_list)


State 136

   45 exp: deref_var •  ['<', '>', '=', '+', '-', '*', '/', '^', '.', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC]
   79 assign_stmt: deref_var • A_ASSIGN exp

    A_ASSIGN  shift, and go to state 152

    $default  reduce using rule 45 (exp)


State 137

   43 exp: var_access •  ['<', '>', '=', '+', '-', '*', '/', '^', '.', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC]
   78 assign_stmt: var_access • A_ASSIGN exp

    A_ASSIGN  shift, and go to state 153

    $default  reduce using rule 43 (exp)


State 138

   33 stmt_sequence: stmt •  [A_END, A_ELSE, A_FI, A_OD, A_ESAC, A_OTHERWISE, '|']
   34              | stmt • ';' stmt_sequence

    ';'  shift, and go to state 154

    $default  reduce using rule 33 (stmt_sequence)


State 139

   73 stmt: assign_stmt •

    $default  reduce using rule 73 (stmt)


State 140

   74 stmt: if_stmt •

    $default  reduce using rule 74 (stmt)


State 141

   75 stmt: while_stmt •

    $default  reduce using rule 75 (stmt)


State 142

   76 stmt: return_stmt •

    $default  reduce using rule 76 (stmt)


State 143

   77 stmt: call_stmt •

    $default  reduce using rule 77 (stmt)


State 144

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   98 call_stmt: A_NAME '(' • optional_arg_list ')'
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'
   99                 | A_NAME '(' • optional_arg_list ')'
  100 optional_arg_list: ε •  [')']
  101                  | • arg_list
  102 arg_list: • exp
  103         | • arg_list ',' exp

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    $default  reduce using rule 100 (optional_arg_list)

    exp                go to state 93
    ref_var            go to state 50
    deref_var          go to state 51
    var_access         go to state 52
    literal            go to state 53
    bool_literal       go to state 54
    call_stmt_as_exp   go to state 55
    optional_arg_list  go to state 155
    arg_list           go to state 95


State 145

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME
   80 if_stmt: A_IF exp • A_THEN stmt_list optional_else_clause A_FI

    A_THEN                shift, and go to state 156
    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84


State 146

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME
   94 while_stmt: A_WHILE exp • A_DO stmt_list A_OD

    A_DO                  shift, and go to state 157
    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84


State 147

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME
   97 optional_exp_val: exp •  [A_END, A_ELSE, A_FI, A_OD, A_ESAC, A_OTHERWISE, ';', '|']

    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84

    $default  reduce using rule 97 (optional_exp_val)


State 148

   95 return_stmt: A_RETURN optional_exp_val •

    $default  reduce using rule 95 (return_stmt)


State 149

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME
   81 if_stmt: A_UNLESS exp • A_DO stmt_list optional_else_clause A_OD

    A_DO                  shift, and go to state 158
    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84


State 150

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME
   82 if_stmt: A_CASE exp • A_OF case_list optional_otherwise_clause A_ESAC

    A_OF                  shift, and go to state 159
    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84


State 151

   21 proc_declaration: A_PROCEDURE A_NAME '(' optional_param_list ')' optional_return_type A_BEGIN optional_proc_decls_in_block stmt_list A_END •

    $default  reduce using rule 21 (proc_declaration)


State 152

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   79 assign_stmt: deref_var A_ASSIGN • exp
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 160
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 153

   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   78 assign_stmt: var_access A_ASSIGN • exp
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 39
    STRING_LITERAL  shift, and go to state 40
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    exp               go to state 161
    ref_var           go to state 50
    deref_var         go to state 51
    var_access        go to state 52
    literal           go to state 53
    bool_literal      go to state 54
    call_stmt_as_exp  go to state 55


State 154

   33 stmt_sequence: • stmt
   34              | • stmt ';' stmt_sequence
   34              | stmt ';' • stmt_sequence
   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   73 stmt: • assign_stmt
   74     | • if_stmt
   75     | • while_stmt
   76     | • return_stmt
   77     | • call_stmt
   78 assign_stmt: • var_access A_ASSIGN exp
   79            | • deref_var A_ASSIGN exp
   80 if_stmt: • A_IF exp A_THEN stmt_list optional_else_clause A_FI
   81        | • A_UNLESS exp A_DO stmt_list optional_else_clause A_OD
   82        | • A_CASE exp A_OF case_list optional_otherwise_clause A_ESAC
   94 while_stmt: • A_WHILE exp A_DO stmt_list A_OD
   95 return_stmt: • A_RETURN optional_exp_val
   98 call_stmt: • A_NAME '(' optional_arg_list ')'
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 128
    STRING_LITERAL  shift, and go to state 40
    A_IF            shift, and go to state 129
    A_WHILE         shift, and go to state 130
    A_RETURN        shift, and go to state 131
    A_UNLESS        shift, and go to state 132
    A_CASE          shift, and go to state 133
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    stmt_sequence     go to state 162
    exp               go to state 96
    ref_var           go to state 50
    deref_var         go to state 136
    var_access        go to state 137
    literal           go to state 53
    bool_literal      go to state 54
    stmt              go to state 138
    assign_stmt       go to state 139
    if_stmt           go to state 140
    while_stmt        go to state 141
    return_stmt       go to state 142
    call_stmt         go to state 143
    call_stmt_as_exp  go to state 55


State 155

   98 call_stmt: A_NAME '(' optional_arg_list • ')'
   99 call_stmt_as_exp: A_NAME '(' optional_arg_list • ')'

    ')'  shift, and go to state 163


State 156

   31 stmt_list: ε •  [A_ELSE, A_FI]
   32          | • stmt_sequence
   33 stmt_sequence: • stmt
   34              | • stmt ';' stmt_sequence
   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   73 stmt: • assign_stmt
   74     | • if_stmt
   75     | • while_stmt
   76     | • return_stmt
   77     | • call_stmt
   78 assign_stmt: • var_access A_ASSIGN exp
   79            | • deref_var A_ASSIGN exp
   80 if_stmt: • A_IF exp A_THEN stmt_list optional_else_clause A_FI
   80        | A_IF exp A_THEN • stmt_list optional_else_clause A_FI
   81        | • A_UNLESS exp A_DO stmt_list optional_else_clause A_OD
   82        | • A_CASE exp A_OF case_list optional_otherwise_clause A_ESAC
   94 while_stmt: • A_WHILE exp A_DO stmt_list A_OD
   95 return_stmt: • A_RETURN optional_exp_val
   98 call_stmt: • A_NAME '(' optional_arg_list ')'
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 128
    STRING_LITERAL  shift, and go to state 40
    A_IF            shift, and go to state 129
    A_WHILE         shift, and go to state 130
    A_RETURN        shift, and go to state 131
    A_UNLESS        shift, and go to state 132
    A_CASE          shift, and go to state 133
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    $default  reduce using rule 31 (stmt_list)

    stmt_list         go to state 164
    stmt_sequence     go to state 135
    exp               go to state 96
    ref_var           go to state 50
    deref_var         go to state 136
    var_access        go to state 137
    literal           go to state 53
    bool_literal      go to state 54
    stmt              go to state 138
    assign_stmt       go to state 139
    if_stmt           go to state 140
    while_stmt        go to state 141
    return_stmt       go to state 142
    call_stmt         go to state 143
    call_stmt_as_exp  go to state 55


State 157

   31 stmt_list: ε •  [A_OD]
   32          | • stmt_sequence
   33 stmt_sequence: • stmt
   34              | • stmt ';' stmt_sequence
   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   73 stmt: • assign_stmt
   74     | • if_stmt
   75     | • while_stmt
   76     | • return_stmt
   77     | • call_stmt
   78 assign_stmt: • var_access A_ASSIGN exp
   79            | • deref_var A_ASSIGN exp
   80 if_stmt: • A_IF exp A_THEN stmt_list optional_else_clause A_FI
   81        | • A_UNLESS exp A_DO stmt_list optional_else_clause A_OD
   82        | • A_CASE exp A_OF case_list optional_otherwise_clause A_ESAC
   94 while_stmt: • A_WHILE exp A_DO stmt_list A_OD
   94           | A_WHILE exp A_DO • stmt_list A_OD
   95 return_stmt: • A_RETURN optional_exp_val
   98 call_stmt: • A_NAME '(' optional_arg_list ')'
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 128
    STRING_LITERAL  shift, and go to state 40
    A_IF            shift, and go to state 129
    A_WHILE         shift, and go to state 130
    A_RETURN        shift, and go to state 131
    A_UNLESS        shift, and go to state 132
    A_CASE          shift, and go to state 133
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    $default  reduce using rule 31 (stmt_list)

    stmt_list         go to state 165
    stmt_sequence     go to state 135
    exp               go to state 96
    ref_var           go to state 50
    deref_var         go to state 136
    var_access        go to state 137
    literal           go to state 53
    bool_literal      go to state 54
    stmt              go to state 138
    assign_stmt       go to state 139
    if_stmt           go to state 140
    while_stmt        go to state 141
    return_stmt       go to state 142
    call_stmt         go to state 143
    call_stmt_as_exp  go to state 55


State 158

   31 stmt_list: ε •  [A_ELSE, A_OD]
   32          | • stmt_sequence
   33 stmt_sequence: • stmt
   34              | • stmt ';' stmt_sequence
   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   73 stmt: • assign_stmt
   74     | • if_stmt
   75     | • while_stmt
   76     | • return_stmt
   77     | • call_stmt
   78 assign_stmt: • var_access A_ASSIGN exp
   79            | • deref_var A_ASSIGN exp
   80 if_stmt: • A_IF exp A_THEN stmt_list optional_else_clause A_FI
   81        | • A_UNLESS exp A_DO stmt_list optional_else_clause A_OD
   81        | A_UNLESS exp A_DO • stmt_list optional_else_clause A_OD
   82        | • A_CASE exp A_OF case_list optional_otherwise_clause A_ESAC
   94 while_stmt: • A_WHILE exp A_DO stmt_list A_OD
   95 return_stmt: • A_RETURN optional_exp_val
   98 call_stmt: • A_NAME '(' optional_arg_list ')'
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 128
    STRING_LITERAL  shift, and go to state 40
    A_IF            shift, and go to state 129
    A_WHILE         shift, and go to state 130
    A_RETURN        shift, and go to state 131
    A_UNLESS        shift, and go to state 132
    A_CASE          shift, and go to state 133
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    $default  reduce using rule 31 (stmt_list)

    stmt_list         go to state 166
    stmt_sequence     go to state 135
    exp               go to state 96
    ref_var           go to state 50
    deref_var         go to state 136
    var_access        go to state 137
    literal           go to state 53
    bool_literal      go to state 54
    stmt              go to state 138
    assign_stmt       go to state 139
    if_stmt           go to state 140
    while_stmt        go to state 141
    return_stmt       go to state 142
    call_stmt         go to state 143
    call_stmt_as_exp  go to state 55


State 159

   82 if_stmt: A_CASE exp A_OF • case_list optional_otherwise_clause A_ESAC
   85 case_list: • case_clause
   86          | • case_list '|' case_clause
   87 case_clause: • case_label_list ':' stmt_list
   88 case_label_list: • case_label_element
   89                | • case_label_list ',' case_label_element
   90 case_label_element: • INT_LITERAL
   91                   | • INT_LITERAL A_RANGE INT_LITERAL

    INT_LITERAL  shift, and go to state 167

    case_list           go to state 168
    case_clause         go to state 169
    case_label_list     go to state 170
    case_label_element  go to state 171


State 160

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME
   79 assign_stmt: deref_var A_ASSIGN exp •  [A_END, A_ELSE, A_FI, A_OD, A_ESAC, A_OTHERWISE, ';', '|']

    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84

    $default  reduce using rule 79 (assign_stmt)


State 161

   48 exp: exp • A_OR_LOGIC exp
   49    | exp • A_AND_LOGIC exp
   50    | exp • '<' exp
   51    | exp • A_LESS_THAN_EQUAL exp
   52    | exp • '>' exp
   53    | exp • A_GREATER_THAN_EQUAL exp
   54    | exp • '=' exp
   55    | exp • A_DIFFERENT exp
   56    | exp • '+' exp
   57    | exp • '-' exp
   58    | exp • '*' exp
   59    | exp • '/' exp
   60    | exp • '^' exp
   65 var_access: exp • '.' A_NAME
   78 assign_stmt: var_access A_ASSIGN exp •  [A_END, A_ELSE, A_FI, A_OD, A_ESAC, A_OTHERWISE, ';', '|']

    '<'                   shift, and go to state 71
    '>'                   shift, and go to state 72
    '='                   shift, and go to state 73
    '+'                   shift, and go to state 74
    '-'                   shift, and go to state 75
    '*'                   shift, and go to state 76
    '/'                   shift, and go to state 77
    '^'                   shift, and go to state 78
    '.'                   shift, and go to state 79
    A_LESS_THAN_EQUAL     shift, and go to state 80
    A_GREATER_THAN_EQUAL  shift, and go to state 81
    A_DIFFERENT           shift, and go to state 82
    A_OR_LOGIC            shift, and go to state 83
    A_AND_LOGIC           shift, and go to state 84

    $default  reduce using rule 78 (assign_stmt)


State 162

   34 stmt_sequence: stmt ';' stmt_sequence •

    $default  reduce using rule 34 (stmt_sequence)


State 163

   98 call_stmt: A_NAME '(' optional_arg_list ')' •  [A_END, A_ELSE, A_FI, A_OD, A_ESAC, A_OTHERWISE, ';', '|']
   99 call_stmt_as_exp: A_NAME '(' optional_arg_list ')' •  ['<', '>', '=', '+', '-', '*', '/', '^', '.', A_LESS_THAN_EQUAL, A_GREATER_THAN_EQUAL, A_DIFFERENT, A_OR_LOGIC, A_AND_LOGIC]

    A_END        reduce using rule 98 (call_stmt)
    A_ELSE       reduce using rule 98 (call_stmt)
    A_FI         reduce using rule 98 (call_stmt)
    A_OD         reduce using rule 98 (call_stmt)
    A_ESAC       reduce using rule 98 (call_stmt)
    A_OTHERWISE  reduce using rule 98 (call_stmt)
    ';'          reduce using rule 98 (call_stmt)
    '|'          reduce using rule 98 (call_stmt)
    $default     reduce using rule 99 (call_stmt_as_exp)


State 164

   80 if_stmt: A_IF exp A_THEN stmt_list • optional_else_clause A_FI
   83 optional_else_clause: ε •  [A_FI]
   84                     | • A_ELSE stmt_list

    A_ELSE  shift, and go to state 172

    $default  reduce using rule 83 (optional_else_clause)

    optional_else_clause  go to state 173


State 165

   94 while_stmt: A_WHILE exp A_DO stmt_list • A_OD

    A_OD  shift, and go to state 174


State 166

   81 if_stmt: A_UNLESS exp A_DO stmt_list • optional_else_clause A_OD
   83 optional_else_clause: ε •  [A_OD]
   84                     | • A_ELSE stmt_list

    A_ELSE  shift, and go to state 172

    $default  reduce using rule 83 (optional_else_clause)

    optional_else_clause  go to state 175


State 167

   90 case_label_element: INT_LITERAL •  [':', ',']
   91                   | INT_LITERAL • A_RANGE INT_LITERAL

    A_RANGE  shift, and go to state 176

    $default  reduce using rule 90 (case_label_element)


State 168

   82 if_stmt: A_CASE exp A_OF case_list • optional_otherwise_clause A_ESAC
   86 case_list: case_list • '|' case_clause
   92 optional_otherwise_clause: ε •  [A_ESAC]
   93                          | • A_OTHERWISE stmt_list

    A_OTHERWISE  shift, and go to state 177
    '|'          shift, and go to state 178

    $default  reduce using rule 92 (optional_otherwise_clause)

    optional_otherwise_clause  go to state 179


State 169

   85 case_list: case_clause •

    $default  reduce using rule 85 (case_list)


State 170

   87 case_clause: case_label_list • ':' stmt_list
   89 case_label_list: case_label_list • ',' case_label_element

    ':'  shift, and go to state 180
    ','  shift, and go to state 181


State 171

   88 case_label_list: case_label_element •

    $default  reduce using rule 88 (case_label_list)


State 172

   31 stmt_list: ε •  [A_FI, A_OD]
   32          | • stmt_sequence
   33 stmt_sequence: • stmt
   34              | • stmt ';' stmt_sequence
   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   73 stmt: • assign_stmt
   74     | • if_stmt
   75     | • while_stmt
   76     | • return_stmt
   77     | • call_stmt
   78 assign_stmt: • var_access A_ASSIGN exp
   79            | • deref_var A_ASSIGN exp
   80 if_stmt: • A_IF exp A_THEN stmt_list optional_else_clause A_FI
   81        | • A_UNLESS exp A_DO stmt_list optional_else_clause A_OD
   82        | • A_CASE exp A_OF case_list optional_otherwise_clause A_ESAC
   84 optional_else_clause: A_ELSE • stmt_list
   94 while_stmt: • A_WHILE exp A_DO stmt_list A_OD
   95 return_stmt: • A_RETURN optional_exp_val
   98 call_stmt: • A_NAME '(' optional_arg_list ')'
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 128
    STRING_LITERAL  shift, and go to state 40
    A_IF            shift, and go to state 129
    A_WHILE         shift, and go to state 130
    A_RETURN        shift, and go to state 131
    A_UNLESS        shift, and go to state 132
    A_CASE          shift, and go to state 133
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    $default  reduce using rule 31 (stmt_list)

    stmt_list         go to state 182
    stmt_sequence     go to state 135
    exp               go to state 96
    ref_var           go to state 50
    deref_var         go to state 136
    var_access        go to state 137
    literal           go to state 53
    bool_literal      go to state 54
    stmt              go to state 138
    assign_stmt       go to state 139
    if_stmt           go to state 140
    while_stmt        go to state 141
    return_stmt       go to state 142
    call_stmt         go to state 143
    call_stmt_as_exp  go to state 55


State 173

   80 if_stmt: A_IF exp A_THEN stmt_list optional_else_clause • A_FI

    A_FI  shift, and go to state 183


State 174

   94 while_stmt: A_WHILE exp A_DO stmt_list A_OD •

    $default  reduce using rule 94 (while_stmt)


State 175

   81 if_stmt: A_UNLESS exp A_DO stmt_list optional_else_clause • A_OD

    A_OD  shift, and go to state 184


State 176

   91 case_label_element: INT_LITERAL A_RANGE • INT_LITERAL

    INT_LITERAL  shift, and go to state 185


State 177

   31 stmt_list: ε •  [A_ESAC]
   32          | • stmt_sequence
   33 stmt_sequence: • stmt
   34              | • stmt ';' stmt_sequence
   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   73 stmt: • assign_stmt
   74     | • if_stmt
   75     | • while_stmt
   76     | • return_stmt
   77     | • call_stmt
   78 assign_stmt: • var_access A_ASSIGN exp
   79            | • deref_var A_ASSIGN exp
   80 if_stmt: • A_IF exp A_THEN stmt_list optional_else_clause A_FI
   81        | • A_UNLESS exp A_DO stmt_list optional_else_clause A_OD
   82        | • A_CASE exp A_OF case_list optional_otherwise_clause A_ESAC
   93 optional_otherwise_clause: A_OTHERWISE • stmt_list
   94 while_stmt: • A_WHILE exp A_DO stmt_list A_OD
   95 return_stmt: • A_RETURN optional_exp_val
   98 call_stmt: • A_NAME '(' optional_arg_list ')'
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 128
    STRING_LITERAL  shift, and go to state 40
    A_IF            shift, and go to state 129
    A_WHILE         shift, and go to state 130
    A_RETURN        shift, and go to state 131
    A_UNLESS        shift, and go to state 132
    A_CASE          shift, and go to state 133
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    $default  reduce using rule 31 (stmt_list)

    stmt_list         go to state 186
    stmt_sequence     go to state 135
    exp               go to state 96
    ref_var           go to state 50
    deref_var         go to state 136
    var_access        go to state 137
    literal           go to state 53
    bool_literal      go to state 54
    stmt              go to state 138
    assign_stmt       go to state 139
    if_stmt           go to state 140
    while_stmt        go to state 141
    return_stmt       go to state 142
    call_stmt         go to state 143
    call_stmt_as_exp  go to state 55


State 178

   86 case_list: case_list '|' • case_clause
   87 case_clause: • case_label_list ':' stmt_list
   88 case_label_list: • case_label_element
   89                | • case_label_list ',' case_label_element
   90 case_label_element: • INT_LITERAL
   91                   | • INT_LITERAL A_RANGE INT_LITERAL

    INT_LITERAL  shift, and go to state 167

    case_clause         go to state 187
    case_label_list     go to state 170
    case_label_element  go to state 171


State 179

   82 if_stmt: A_CASE exp A_OF case_list optional_otherwise_clause • A_ESAC

    A_ESAC  shift, and go to state 188


State 180

   31 stmt_list: ε •  [A_ESAC, A_OTHERWISE, '|']
   32          | • stmt_sequence
   33 stmt_sequence: • stmt
   34              | • stmt ';' stmt_sequence
   40 exp: • literal
   41    | • call_stmt_as_exp
   42    | • A_NEW A_NAME
   43    | • var_access
   44    | • ref_var
   45    | • deref_var
   46    | • '(' exp ')'
   47    | • A_NOT exp
   48    | • exp A_OR_LOGIC exp
   49    | • exp A_AND_LOGIC exp
   50    | • exp '<' exp
   51    | • exp A_LESS_THAN_EQUAL exp
   52    | • exp '>' exp
   53    | • exp A_GREATER_THAN_EQUAL exp
   54    | • exp '=' exp
   55    | • exp A_DIFFERENT exp
   56    | • exp '+' exp
   57    | • exp '-' exp
   58    | • exp '*' exp
   59    | • exp '/' exp
   60    | • exp '^' exp
   61 ref_var: • A_REF '(' var_access ')'
   62 deref_var: • A_DEREF '(' var_access ')'
   63          | • A_DEREF '(' deref_var ')'
   64 var_access: • A_NAME
   65           | • exp '.' A_NAME
   66 literal: • FLOAT_LITERAL
   67        | • INT_LITERAL
   68        | • STRING_LITERAL
   69        | • bool_literal
   70        | • A_NULL
   71 bool_literal: • A_TRUE
   72             | • A_FALSE
   73 stmt: • assign_stmt
   74     | • if_stmt
   75     | • while_stmt
   76     | • return_stmt
   77     | • call_stmt
   78 assign_stmt: • var_access A_ASSIGN exp
   79            | • deref_var A_ASSIGN exp
   80 if_stmt: • A_IF exp A_THEN stmt_list optional_else_clause A_FI
   81        | • A_UNLESS exp A_DO stmt_list optional_else_clause A_OD
   82        | • A_CASE exp A_OF case_list optional_otherwise_clause A_ESAC
   87 case_clause: case_label_list ':' • stmt_list
   94 while_stmt: • A_WHILE exp A_DO stmt_list A_OD
   95 return_stmt: • A_RETURN optional_exp_val
   98 call_stmt: • A_NAME '(' optional_arg_list ')'
   99 call_stmt_as_exp: • A_NAME '(' optional_arg_list ')'

    INT_LITERAL     shift, and go to state 37
    FLOAT_LITERAL   shift, and go to state 38
    A_NAME          shift, and go to state 128
    STRING_LITERAL  shift, and go to state 40
    A_IF            shift, and go to state 129
    A_WHILE         shift, and go to state 130
    A_RETURN        shift, and go to state 131
    A_UNLESS        shift, and go to state 132
    A_CASE          shift, and go to state 133
    A_TRUE          shift, and go to state 41
    A_FALSE         shift, and go to state 42
    A_NULL          shift, and go to state 43
    A_NOT           shift, and go to state 44
    A_NEW           shift, and go to state 45
    A_REF           shift, and go to state 46
    A_DEREF         shift, and go to state 47
    '('             shift, and go to state 48

    $default  reduce using rule 31 (stmt_list)

    stmt_list         go to state 189
    stmt_sequence     go to state 135
    exp               go to state 96
    ref_var           go to state 50
    deref_var         go to state 136
    var_access        go to state 137
    literal           go to state 53
    bool_literal      go to state 54
    stmt              go to state 138
    assign_stmt       go to state 139
    if_stmt           go to state 140
    while_stmt        go to state 141
    return_stmt       go to state 142
    call_stmt         go to state 143
    call_stmt_as_exp  go to state 55


State 181

   89 case_label_list: case_label_list ',' • case_label_element
   90 case_label_element: • INT_LITERAL
   91                   | • INT_LITERAL A_RANGE INT_LITERAL

    INT_LITERAL  shift, and go to state 167

    case_label_element  go to state 190


State 182

   84 optional_else_clause: A_ELSE stmt_list •

    $default  reduce using rule 84 (optional_else_clause)


State 183

   80 if_stmt: A_IF exp A_THEN stmt_list optional_else_clause A_FI •

    $default  reduce using rule 80 (if_stmt)


State 184

   81 if_stmt: A_UNLESS exp A_DO stmt_list optional_else_clause A_OD •

    $default  reduce using rule 81 (if_stmt)


State 185

   91 case_label_element: INT_LITERAL A_RANGE INT_LITERAL •

    $default  reduce using rule 91 (case_label_element)


State 186

   93 optional_otherwise_clause: A_OTHERWISE stmt_list •

    $default  reduce using rule 93 (optional_otherwise_clause)


State 187

   86 case_list: case_list '|' case_clause •

    $default  reduce using rule 86 (case_list)


State 188

   82 if_stmt: A_CASE exp A_OF case_list optional_otherwise_clause A_ESAC •

    $default  reduce using rule 82 (if_stmt)


State 189

   87 case_clause: case_label_list ':' stmt_list •

    $default  reduce using rule 87 (case_clause)


State 190

   89 case_label_list: case_label_list ',' case_label_element •

    $default  reduce using rule 89 (case_label_list)
